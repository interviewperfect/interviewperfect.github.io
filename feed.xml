<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>InterviewPerfect</title>
    <description>Learn how to pass technical interviews from companies such as Google, Facebook, and LinkedIn with flying colours. InterviewPerfect is a blog dedicated to solving interview questions, and explaining the step-by-step logic behind each solution. Good luck in job searching!
</description>
    <link>http://interviewperfect.github.io//</link>
    <atom:link href="http://interviewperfect.github.io//feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Wed, 29 Jun 2016 03:08:19 -0400</pubDate>
    <lastBuildDate>Wed, 29 Jun 2016 03:08:19 -0400</lastBuildDate>
    <generator>Jekyll v3.1.2</generator>
    
      <item>
        <title>[Interview Problem] Water Jugs</title>
        <description>&lt;h1 id=&quot;problem&quot;&gt;Problem&lt;/h1&gt;

&lt;p&gt;You have two water jugs. One can hold &lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt; liters and another &lt;code class=&quot;highlighter-rouge&quot;&gt;y&lt;/code&gt; liters. You want the total amount of water in the jugs to be &lt;code class=&quot;highlighter-rouge&quot;&gt;z&lt;/code&gt; liters at the end but it’s not always possible. Here are the possible moves you can do.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Fully empty a jug&lt;/li&gt;
  &lt;li&gt;Fully fill a jug&lt;/li&gt;
  &lt;li&gt;Pour water from a jug to another jug until the latter is full or the former is empty&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Write a function that takes in &lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;y&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;z&lt;/code&gt; and returns &lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt; depending on if holding &lt;code class=&quot;highlighter-rouge&quot;&gt;z&lt;/code&gt; liters using the two jugs is possible.&lt;/p&gt;

&lt;h1 id=&quot;arithmetic-solution&quot;&gt;Arithmetic Solution&lt;/h1&gt;

&lt;p&gt;How I tackled the problem was by working with examples, trying to generate new &lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;y&lt;/code&gt; combinations within an example, and then trying to figure out a pattern in generating these combinations. The challenge with this approach is that it may seem disconnected and random at first but with patience, you’ll be able to find an efficient way to iterate through all possible &lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;y&lt;/code&gt; combinations.&lt;/p&gt;

&lt;p&gt;The first thing I did to make the problem easier is to not think in terms of &lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;y&lt;/code&gt; but small and large.&lt;/p&gt;

&lt;p&gt;The next thing I realized is that there is very little freedom in working with the large jug. When filling the large jug, you really have 3 options available at the end. You can pour it all out which is pointless, completely filling the small jug and pouring the small jug out, or completely filling the small jug and filling the large jug. You are offered much more flexibility in initiating actions with the small jug and manipulating the contents of the large jug using the small jug.&lt;/p&gt;

&lt;p&gt;Then, I made up an example and played around with it. Let’s try &lt;code class=&quot;highlighter-rouge&quot;&gt;x=5&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;y=7&lt;/code&gt;, and &lt;code class=&quot;highlighter-rouge&quot;&gt;z=2&lt;/code&gt;.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Step #&lt;/th&gt;
      &lt;th&gt;x&lt;/th&gt;
      &lt;th&gt;y&lt;/th&gt;
      &lt;th&gt;sum&lt;/th&gt;
      &lt;th&gt;action&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;start&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;fill small, small to large&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
      &lt;td&gt;10&lt;/td&gt;
      &lt;td&gt;fill small, small to large&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;pour large, small to large&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
      &lt;td&gt;8&lt;/td&gt;
      &lt;td&gt;fill small, small to large&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;pour large, small to large&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;7&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;fill small, small to large&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;8&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
      &lt;td&gt;11&lt;/td&gt;
      &lt;td&gt;fill small, small to large&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;9&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;pour large, small to large&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;10&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
      &lt;td&gt;9&lt;/td&gt;
      &lt;td&gt;fill small, small to large&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;11&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;pour large, small to large&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;The answer to the above problem is true, since we reached a sum of 2 which is what &lt;code class=&quot;highlighter-rouge&quot;&gt;z&lt;/code&gt; is.&lt;/p&gt;

&lt;p&gt;The main takeaway from the above example is the generation of new values of &lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt; after each round. In fact, if you kept going you will realize the pattern repeats.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Step #&lt;/th&gt;
      &lt;th&gt;x&lt;/th&gt;
      &lt;th&gt;y&lt;/th&gt;
      &lt;th&gt;sum&lt;/th&gt;
      &lt;th&gt;action&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;11&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;pour large, small to large&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;12&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
      &lt;td&gt;fill small, small to large&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;13&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;pour large, small to large&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;14&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;fill small, small to large&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;15&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
      &lt;td&gt;10&lt;/td&gt;
      &lt;td&gt;fill small, small to large&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;…&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Notice steps 1 to 3 and steps 13 to 15 are the same. This is actually really good! It seems like we have exhausted all the possible combinations once the pattern repeats. Trying this on other examples confirms this observation.&lt;/p&gt;

&lt;p&gt;The next step is to understand how we generated these numbers. Notice that we only &lt;code class=&quot;highlighter-rouge&quot;&gt;pour large, small to large&lt;/code&gt; when large is full? And notice that at that point &lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt; represents the &lt;code class=&quot;highlighter-rouge&quot;&gt;overflow&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The overflow then serves to be the &lt;code class=&quot;highlighter-rouge&quot;&gt;base&lt;/code&gt; amount of water for the next iteration. The &lt;code class=&quot;highlighter-rouge&quot;&gt;base&lt;/code&gt; effectively modifies the size of the large jug and filling the large jug with different bases results in new sums of water. In fact, as long as there is &lt;code class=&quot;highlighter-rouge&quot;&gt;overflow&lt;/code&gt;, the algorithm will keep going.&lt;/p&gt;

&lt;p&gt;An important step we need to figure out is how the algorithm terminates. Well, since we noticed that the algorithm started to generate repeated output after a while, we can examine the point at which the repeated output starts getting generated. We notice that it’s the point when &lt;code class=&quot;highlighter-rouge&quot;&gt;overflow=0&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Using this idea, we can write out the algorithm.&lt;/p&gt;

&lt;p&gt;We would also need to be careful of edge cases, such as when &lt;code class=&quot;highlighter-rouge&quot;&gt;z == 0&lt;/code&gt; or one of the jugs has 0 size.&lt;/p&gt;

&lt;h2 id=&quot;coded-solution-python&quot;&gt;Coded Solution (Python)&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def water_jug(self, x, y, z):
    # edge cases
    if z == 0:
        return True
    elif z &amp;gt; (x + y): 
        return False
    elif z == (x + y): 
        return True
    elif x == 0 or y == 0:
        return False

    # set small and large
    if y &amp;gt; x:
        s, l = x, y
    else:
        s, l = y, x

    # start generating
    base = 0

    while True:
        # determine overflow
        overflow = 0
        if (l - base) % s != 0:
            overflow = s - (l - base) % s

        if ((z - base) % s == 0) and (l + overflow) &amp;gt;= z:
            return True
            
        # check terminating condition
        if overflow == 0:
            return False

        base = overflow
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h1 id=&quot;graph-solution&quot;&gt;Graph Solution&lt;/h1&gt;

&lt;p&gt;Another solution that is not as efficient, but easier to reason about, is to model the problem as a graph problem. The vertices are different &lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;y&lt;/code&gt; combinations. Two vertices, &lt;code class=&quot;highlighter-rouge&quot;&gt;(x1, y1)&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;(x2, y2)&lt;/code&gt; have an edge between them if an action can change &lt;code class=&quot;highlighter-rouge&quot;&gt;x1&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;y1&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;x2&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;y2&lt;/code&gt;. Edges have direction. We can determine if we can get to z by breadth-first searching the entire graph and checking the sum of &lt;code class=&quot;highlighter-rouge&quot;&gt;x + y&lt;/code&gt; at each node.&lt;/p&gt;

&lt;p&gt;Modelling problems with graphs not only makes it easier, it also makes for smart-sounding solutions.&lt;/p&gt;
</description>
        <pubDate>Tue, 28 Jun 2016 01:35:16 -0400</pubDate>
        <link>http://interviewperfect.github.io//interview-problem-water-jugs/</link>
        <guid isPermaLink="true">http://interviewperfect.github.io//interview-problem-water-jugs/</guid>
        
        
        <category>hard</category>
        
        <category>math</category>
        
      </item>
    
      <item>
        <title>[Interview Problem] DNA Patterns</title>
        <description>&lt;h2 id=&quot;problem&quot;&gt;Problem&lt;/h2&gt;

&lt;p&gt;There are four main building blocks of DNA. They are known as nucleotides and can be denoted by characters A (adenine), C (cytosine), G (guanine), and T (thymine). A strand of DNA is made of a sequence of nucleotides and thus can be represented as a string composed of A, C, G, and T. For example, &lt;code class=&quot;highlighter-rouge&quot;&gt;ACGACTGCTAGCTTGCCGGGTA&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The problem is, given a strand of DNA, how do you efficiently find all 10-letter long sequences that occur more than once? Sequences can overlap.&lt;/p&gt;

&lt;h2 id=&quot;solution&quot;&gt;Solution&lt;/h2&gt;

&lt;p&gt;The brute force solution is to iterate through every single 10-letter long sequence and then check if another such sequence can be found in the overall sequence. The complexity of this solution is $O(n^2)$.&lt;/p&gt;

&lt;p&gt;In the previous solution, you’ll probably notice that we would be iterating over a large portion of the DNA sequence repeatedly. The purpose is to check if our current 10-letter sequence appears again in the overall sequence. But we could invert this. As we iterate across the overall sequence, for each new 10-letter sequence we encounter, check if we have seen this sequence before. If we used a hash table to store all 10-letter sequences seen, then the check can be done in $O(1)$ and our new algorithm is $O(n)$.&lt;/p&gt;

&lt;h2 id=&quot;coded-solution-pseudocode&quot;&gt;Coded solution (Pseudocode)&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;hash_table = {}
repeating = []
for i in sequence.length - 10:
  if sequence[i, i + 10] in hash_table:
    Found a repeating sequence!
  else:
    hash_table.add(sequence[i, i + 10])
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;suffix-trees&quot;&gt;Suffix trees&lt;/h2&gt;

&lt;p&gt;This problem can also be solved using a suffix tree. Suffix trees are very useful when working with large bodies of text. For one, it allows us to search for the number of occurences of a substring in a body of text, no matter how large, in $O(m)$ time where $m$ is the length of the string. A suffix tree can be constructed in $O(n)$ time where $n$ is the length of the body of text.&lt;/p&gt;

&lt;p&gt;So for our problem, given our overall sequence of DNA is length n, we construct the suffix tree in $O(n)$ time and then perform $10(n - 10) = O(n)$ queries of a substring of length 10. Each query takes a constant amount of time so the overall algorithm is $O(n)$.&lt;/p&gt;

&lt;p&gt;However, this is a complex solution and the hash table solution is just as fast, takes up an inconsequential amount of extra space, and most importantly, is much simpler. That being said, it’s good to be aware of suffix trees and how useful they are for string processing.&lt;/p&gt;
</description>
        <pubDate>Mon, 27 Jun 2016 12:01:02 -0400</pubDate>
        <link>http://interviewperfect.github.io//interview-problem-dna-patterns/</link>
        <guid isPermaLink="true">http://interviewperfect.github.io//interview-problem-dna-patterns/</guid>
        
        
        <category>easy</category>
        
        <category>strings</category>
        
      </item>
    
      <item>
        <title>[Google Interview Question] Captive Go Stones</title>
        <description>&lt;h2 id=&quot;problem&quot;&gt;Problem&lt;/h2&gt;

&lt;p&gt;Here’s a very, very simplified explanation for the game of Go. There are two players, one player plays with white stones, the other with black stones. The objective of the game is have surrounded a larger total area of the board with one’s stones than the opponent. Our questions deals with a simple aspect of the game, that of capturing and removing another player’s stones.&lt;/p&gt;

&lt;p&gt;A stone is captured if it, or its group, is surrounded by opposing stones. Opposing stones surround the group of stones by occupying all orthogonally-adjacent points of the group.&lt;/p&gt;

&lt;p&gt;Examples:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;------ ------ ------ -------
| x  | |    | | x  | |xooox|
|xox | |    | |xox | |xo ox|
|xo x| | xx | |xox | |xooox|
| xx | |xoox| | x  | | xxx |
------ ------ ------ -------
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;In the first board, the o stones are not surrounded as there is still one spot the x stones need to fill. In the second board, the o stones are surrounded as their north, west, and east edges are occupied by x stones and their south edge is the end of the board. In the third board, the o stones are surrounded. In the last board, even though all the external edges are occupied by x stones, the o stones are not surrounded as there is a center spot that is empty and must be either filled by an o stone or an x stone for the rest of the o stones to be considered surrounded.&lt;/p&gt;

&lt;p&gt;We want to write a program that, passed with a coordinate of a white stone and a Go board, we need to determine if the white stone is considered surrounded or not.&lt;/p&gt;

&lt;h2 id=&quot;ideas-and-solution&quot;&gt;Ideas and solution&lt;/h2&gt;

&lt;p&gt;We know that a group of stones is surrounded if the group has all edges occupied either by opposing stones or the edge of the board. This means that if there’s a stone in the group that has an edge that is empty, the group of stones is not surrounded. As such, the problem comes down to searching if one such stone in the group exists.&lt;/p&gt;

&lt;p&gt;The fact that this problem involves a grid hints at a graph-related solution. We also know that this problem involves some kind of searching. Let’s try the most basic search algorithm, depth first search (DFS).&lt;/p&gt;

&lt;p&gt;We would start the DFS from the coordinates of the white stone passed to us. The “children” of the stone (AKA grid positions we will search next) will be its north, south, east, and west neighbouring grid positions. At each new grid position we encounter, we check whether the grid is empty or not. If it’s empty, we know that the whole group of white stones we just processed is not surrounded, and thus the original stone we started searching from is not surrounded. If we encounter a black stone, there’s no point in searching further at this point as we encountered an “edge” of the group. The same applies if we encounter an edge of the board. Finally, one last thing we need to make sure is to keep track of all the grid positions we’ve seen so we do not re-search already searched stones.&lt;/p&gt;

&lt;p&gt;As such, we see that DFS solves our problem nice and easily.&lt;/p&gt;

&lt;h2 id=&quot;coded-solution-python&quot;&gt;Coded solution (Python)&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# white stones are denoted by 2, black stones by 1, empty grid positions by 0

def is_captive(x, y, board):
    # check that board exists
    if len(board) == 0 or len(board[0]) == 0:
        return False
    # check that coordinates passed in is within bounds of board
    if x &amp;lt; 0 or x &amp;gt;= len(board) or y &amp;lt; 0 or y &amp;gt;= len(board[0]):
        return False
    # check that grid passed in is a white stone
    if board[x][y] != 2:
        raise Exception()

    # keep track of already searched grip positions
    seen_set = set()
    seen_set.add((x,y))

    # if any of the white stones right beside us is not a captive, we are not a captive
    return __is_captive(x+1, y, board, seen_set) and \
            __is_captive(x-1, y, board, seen_set) and \
            __is_captive(x, y+1, board, seen_set) and \
            __is_captive(x, y-1, board, seen_set)

def __is_captive(x, y, board, seen_set):
    # check if already seen
    if (x,y) in seen_set:
        return True

    seen_set.add((x,y))

    # check if board edge
    if x &amp;lt; 0 or x &amp;gt;= len(board) or y &amp;lt; 0 or y &amp;gt;= len(board[0]):
        return True

    # check if empty block
    if board[x][y] == 0:
        return False

    # check if black piece
    if board[x][y] == 1:
        return True

    # must be white piece, search all neighbours
    return __is_captive(x+1, y, board, seen_set) and \
            __is_captive(x-1, y, board, seen_set) and \
            __is_captive(x, y+1, board, seen_set) and \
            __is_captive(x, y-1, board, seen_set)

print is_captive(2, 1, [
    [ 0, 1, 0, 0, 0],
    [ 1, 2, 1, 0, 0],
    [ 1, 2, 2, 1, 0],
    [ 1, 2, 1, 0, 0],
    [ 0, 1, 0, 0, 0]
])
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Sun, 10 Apr 2016 06:40:20 -0400</pubDate>
        <link>http://interviewperfect.github.io//google-interview-question-captive-go-stones/</link>
        <guid isPermaLink="true">http://interviewperfect.github.io//google-interview-question-captive-go-stones/</guid>
        
        
        <category>easy</category>
        
        <category>graph</category>
        
        <category>google</category>
        
      </item>
    
      <item>
        <title>[Facebook Interview Problem] Word Search</title>
        <description>&lt;p&gt;This was a question I’ve gotten for a Facebook interview. I have a few friends who also have had the same question asked. Enjoy :)&lt;/p&gt;

&lt;h2 id=&quot;problem&quot;&gt;Problem&lt;/h2&gt;

&lt;p&gt;Given an n by m grid of letters and a string, we want to see if there is a chain of letters in the grid that matches the string. The rules for the chain is that each consecutive character can only be directly adjacent to each other (not diagonal) and we cannot reuse a letter.&lt;/p&gt;

&lt;p&gt;For a example, consider a grid like so (we want to match the string “KAPPA”):&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;a | b | k | p | c
-----------------
t | d | a | p | a
-----------------
p | a | k | t | c
-----------------
p | a | t | z | a
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;“KAPPA” can be matched like so and our function would return true:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;a | b | k | p | c
-----------------
t | d | a | p | a
-----------------
P | A | K | t | c
-----------------
P | A | t | z | a
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;ideas-and-solution&quot;&gt;Ideas and solution&lt;/h2&gt;

&lt;p&gt;We would typically start a problem by considering all possible solutions. However, this problem setup gives a big hint on what type of solution we should use. &lt;strong&gt;Typically, grid problems that involve some sort of searching hints at a graph algorithm-based solution&lt;/strong&gt;. We start out by considering the simplest which are depth-first search (DFS) and breadth-first search (BFS). Both aim to solve the same problem but each is more efficient to use or easy to program in certain situations.&lt;/p&gt;

&lt;h3 id=&quot;dfs-or-bfs&quot;&gt;DFS or BFS?&lt;/h3&gt;

&lt;p&gt;This question really comes down to whether our problem is more or less suited for recursion. If more, we should try DFS first, if less, BFS. Problems that are more suitable for recursion are problems that can be broken down into multiple, smaller pieces. This is actually the case for our problem. Consider when we are searching for the word “KAPPA” and we have already found “KA”. Now we only need to find “PPA” and we see that the problem has naturally broken itself down to a smaller, but essentially the same problem. Instead of needing to find the string “KAPPA”, we now need to find the string “PPA”. Thus we decide to try out DFS first.&lt;/p&gt;

&lt;h3 id=&quot;rest-of-the-solution&quot;&gt;Rest of the solution&lt;/h3&gt;

&lt;p&gt;A good start to coding the problem is to think about the overall structure of our solution. A function we would definitely need is a search function that would take in a grid square, search the grid for the word using a modified DFS, and return &lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt;. Let’s call this function &lt;code class=&quot;highlighter-rouge&quot;&gt;search&lt;/code&gt;. Since any grid square could be the start of a valid sequence in the grid, we would need to call &lt;code class=&quot;highlighter-rouge&quot;&gt;search&lt;/code&gt; on each grid square.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;grid = [ ... ]
search_string = &quot;kappa&quot;
for row_i in xrange(len(grid)):
    for col_i in xrange(len(grid[row_i])):
        if search(grid, row_i, col_i, search_string)
            return True
return False
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The search function would search the adjacent squares of the input square for the first character in the string. If we found a square with the first character in the string, it’s a candidate and we need to test it by calling &lt;code class=&quot;highlighter-rouge&quot;&gt;search&lt;/code&gt; on it recursively. Since we already found the first character, we are now effectively searching for a new string which is the old string without the first character.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def search(grid, row_i, col_i, search_string):
    # make sure grid is valid
    if row_i &amp;lt; 0 or row_i &amp;gt;= len(grid):
        return False
    elif col_i &amp;lt; 0 or col_i &amp;gt;= len(grid[row_i]):
        return False

    # found all characters!
    if len(search_string) == 0:
        return True

    # grid doesn&#39;t contain character we are looking for
    if grid[row_i][col_i] != search_string[0]:
        return False

    # grid does contain character, let&#39;s look for the rest of the string
    return search(grid, row_i + 1, col_i, search_string[1:]) or \
        search(grid, row_i - 1, col_i, search_string[1:]) or \
        search(grid, row_i, col_i + 1, search_string[1:]) or \
        search(grid, row_i, col_i - 1, search_string[1:])
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;were-not-done-&quot;&gt;We’re not done :(&lt;/h3&gt;

&lt;p&gt;The solution looks good so far but we’re certainly not done. We have not addressed the other constraint that we cannot reuse squares. This constraint means that whenever we check for a candidate grid to search next, we have to make sure we haven’t used it already. To do so, we need to first know what exactly we have used already. We can keep track of this using an array that we will call the &lt;code class=&quot;highlighter-rouge&quot;&gt;used_list&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The idea will be that the &lt;code class=&quot;highlighter-rouge&quot;&gt;used_list&lt;/code&gt; will grow and shrink with the recursion. Everytime we move down a candidate grid square, we grow the &lt;code class=&quot;highlighter-rouge&quot;&gt;used_list&lt;/code&gt; by adding the candidate to the list and everytime a candidate grid square ends up as a dead end, we shrink the &lt;code class=&quot;highlighter-rouge&quot;&gt;used_list&lt;/code&gt; and move back up the recursion. This will ensure that the &lt;code class=&quot;highlighter-rouge&quot;&gt;used_list&lt;/code&gt; will always contain exactly the grid squares we have used in the search so far. Voila, we have the full solution!&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def search(grid, row_i, col_i, search_string, used_list):
    # make sure grid is valid
    if row_i &amp;lt; 0 or row_i &amp;gt;= len(grid):
        return False
    elif col_i &amp;lt; 0 or col_i &amp;gt;= len(grid[row_i]):
        return False

    # found all characters!
    if len(search_string) == 0:
        return True

    # make sure we&#39;re not on a grid square we&#39;ve already used for this particular search instance
    for seen_row_i, seen_col_i in used_list:
        if seen_row_i == row_i and seen_col_i == col_i:
            return False

    # grid doesn&#39;t contain character we are looking for
    if grid[row_i][col_i] != search_string[0]:
        return False

    used_list.append((row_i, col_i))

    # grid does contain character, let&#39;s look for the rest of the string
    found = search(grid, row_i + 1, col_i, search_string[1:], used_list) or \
        search(grid, row_i - 1, col_i, search_string[1:], used_list) or \
        search(grid, row_i, col_i + 1, search_string[1:], used_list) or \
        search(grid, row_i, col_i - 1, search_string[1:], used_list)

    if found:
        return True
    else:
        # not using this grid anymore...
        used_list.pop()
        return False
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;coded-solution-python&quot;&gt;Coded solution (Python)&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;grid = [
    [ &quot;a&quot;, &quot;b&quot;, &quot;k&quot;, &quot;p&quot;, &quot;c&quot; ],
    [ &quot;t&quot;, &quot;d&quot;, &quot;a&quot;, &quot;p&quot;, &quot;a&quot; ],
    [ &quot;p&quot;, &quot;a&quot;, &quot;k&quot;, &quot;t&quot;, &quot;c&quot; ],
    [ &quot;p&quot;, &quot;a&quot;, &quot;t&quot;, &quot;z&quot;, &quot;a&quot; ]
]
search_string = &quot;kappa&quot;

def search(grid, row_i, col_i, search_string, used_list):
    # make sure grid is valid
    if row_i &amp;lt; 0 or row_i &amp;gt;= len(grid):
        return False
    elif col_i &amp;lt; 0 or col_i &amp;gt;= len(grid[row_i]):
        return False

    # found all characters!
    if len(search_string) == 0:
        return True

    # make sure we&#39;re not on a grid square we&#39;ve already used for this particular search instance
    for seen_row_i, seen_col_i in used_list:
        if seen_row_i == row_i and seen_col_i == col_i:
            return False

    # grid doesn&#39;t contain character we are looking for
    if grid[row_i][col_i] != search_string[0]:
        return False

    used_list.append((row_i, col_i))

    # grid does contain character, let&#39;s look for the rest of the string
    found = search(grid, row_i + 1, col_i, search_string[1:], used_list) or \
        search(grid, row_i - 1, col_i, search_string[1:], used_list) or \
        search(grid, row_i, col_i + 1, search_string[1:], used_list) or \
        search(grid, row_i, col_i - 1, search_string[1:], used_list)

    if found:
        return True
    else:
        # not using this grid anymore...
        used_list.pop()
        return False

def word_search(grid, search_string):
    used_list = []
    for row_i in xrange(len(grid)):
        for col_i in xrange(len(grid[row_i])):
            if search(grid, row_i, col_i, search_string, used_list):
                return True
    return False
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Thu, 07 Apr 2016 02:19:20 -0400</pubDate>
        <link>http://interviewperfect.github.io//facebook-interview-problem-word-search/</link>
        <guid isPermaLink="true">http://interviewperfect.github.io//facebook-interview-problem-word-search/</guid>
        
        
        <category>hard</category>
        
        <category>graphs</category>
        
        <category>facebook</category>
        
      </item>
    
      <item>
        <title>[Interview Problem] Trailing Zeroes</title>
        <description>&lt;p&gt;Sweet and easy to understand problem. Probably hard to solve?&lt;/p&gt;

&lt;h2 id=&quot;problem&quot;&gt;Problem&lt;/h2&gt;

&lt;p&gt;The problem is, given an integer, we want to determine how many trailing zeroes its factorial has. You get an integer’s factorial by multiplying all integers less than and equal to your integer, except for negative integers and zero. So for a number 5, it’s factorial can be found by doing $1 \cdot 2 \cdot 3 \cdot 4 \cdot 5 = 120$. The notation for a factorial, for a given number $n$, is $n!$. As before, $5! = 120$.&lt;/p&gt;

&lt;p&gt;On first thought, you might be considering just doing the multiplication and counting how many times you can divide the result by 10. However, factorials grow at a crazy rate and you might be asked to count the trailing zeroes for something like 100. $100!$ has 158 digits. Doing several multiplications involving 100+ digit numbers is not efficient at all. We can definitely do better.&lt;/p&gt;

&lt;h2 id=&quot;solution&quot;&gt;Solution&lt;/h2&gt;

&lt;p&gt;This problem involves a bit more math than traditional interview problems. The strategy to use for solving this problem is to consider numbers with trailing zeroes and understand how these trailing zeroes occur in the context of multiplication and factors.&lt;/p&gt;

&lt;p&gt;The key property to realize is that whenever you multiply a number by 10, you result in a number with one more trailing zero. In other words, every number with trailing zeroes is divisible by 10, and to take this further, the number of trailing zeroes equal the number of 10 factors the number has.&lt;/p&gt;

&lt;p&gt;Let’s pivot back to the original problem. Before we move on, let’s refer to a number multipled in a factorial as a &lt;strong&gt;factorial term&lt;/strong&gt;. For example, in our prior example, the factorial terms for $5!$ are 1, 2, 3, 4, and 5. Given what we now know about trailing zeroes, is it true that the number of trailing zeroes for a factorial is the sum of the number of 10 factors each factorial term contributes to the multiplication? Immediately we see that that’s not true since $5! = 120$ but none of the factorial terms contain a factor of 10.&lt;/p&gt;

&lt;p&gt;We need to keep exploring this 10 factor idea. How did $5!$ end up having a 10 factor? The next leap in understanding is to realize that 10 itself can be factorized to 2 and 5. Since both numbers are prime numbers, we cannot factorize them any further. At this point, we can see that it’s not really the total number of 10 factors each factorial term contributes, but the total number of 2 and 5 factorial pairs they contribute.&lt;/p&gt;

&lt;p&gt;In fact, the problem can be simplified even further by realizing that since the number of 2 factors is always greater than or equal to the number of 5 factors in a factorial, we really only care about the total number of 5 factors.&lt;/p&gt;

&lt;p&gt;To summarize, in order to obtain our solution, we needed to reach these conclusions:&lt;br /&gt;
1) the number of trailing zeroes of a number equals the number of 10 factors it has
2) 10 can be factorized to prime numbers 2 and 5, so we are really interested in the number of 2 and 5 pairs
3) Since the number of 2 factors is always greater than or equal to the number of 5 factors in a factorial, we only need to worry about the number of 5 factors&lt;/p&gt;

&lt;h2 id=&quot;code-solution-python&quot;&gt;Code solution (Python)&lt;/h2&gt;

&lt;h3 id=&quot;brute-force&quot;&gt;Brute force&lt;/h3&gt;

&lt;p&gt;For each factorial term, determine how many 5 factors it has.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def factorial_trailing_zeros(n):
    trailing_zeroes = 0
    for i in xrange(1, n + 1):
        while(i % 5 == 0):
            trailing_zeroes += 1
            i /= 5
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;smarter&quot;&gt;Smarter&lt;/h3&gt;

&lt;p&gt;This solution is a lot more efficient but more complicated to understand as well. First, we need to realize that multiples of 5 contribute at least one 5 factor, multiples of $5^2 = 25$ contribute at least two 5 factors, multiples of $5^3 = 125$ contribute at least three 5 factors and so on.&lt;/p&gt;

&lt;p&gt;The idea is to count all factorial terms that have a 5 factor, and add the count to the trailing zeroes. Then count all factorial terms that have a 25 factor, and add the count to the trailing zeroes. We do not add double the count for 25 even though multiples of 25 contribute at least two 5 factors since counting all factorial terms that have a 5 factor already accounts for this. We keep doing this for larger powers of 5, stopping at the largest power of 5 less than or equal to n.&lt;/p&gt;

&lt;p&gt;In other words, we want to count the multiples of 5 less than or equal to n, the multiples of 25 less than or equal to n, up till the largest power of 5 less than or equal to n.&lt;/p&gt;

&lt;p&gt;How do we do so? We notice that a multiple of 5 is made of 5s, obviously. As such, we can just divide n by 5 and floor the result which will give us all the multiples of 5 less than or equal to n. For example, 25 is made of five 5s, or 5 + 5 + 5 + 5 + 5. 5 is less than 25, 5 + 5 is less than 25, 5 + 5 + 5 is less than 25, 5 + 5 + 5 + 5 is less than 25. 5 + 5 + 5 + 5 + 5 = 25. Nice, we’ve covered all the multiples of 5 less than or equal to 25. We can extrapolate this logic to higher powers of 5.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def factorial_trailing_zeros(n):
    if n &amp;lt; 5:
        return 0
    largest_pow_of_five_less_than_n = int(math.log(n, 5))
    trailing_zeroes = 0
    for i in xrange(1, largest_pow_of_five_less_than_n + 1):
        divisor = int(math.pow(5, i))
        trailing_zeroes += n / divisor

    return trailing_zeroes
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Thu, 07 Apr 2016 00:20:00 -0400</pubDate>
        <link>http://interviewperfect.github.io//interview-problem-trailing-zeroes/</link>
        <guid isPermaLink="true">http://interviewperfect.github.io//interview-problem-trailing-zeroes/</guid>
        
        
        <category>medium</category>
        
        <category>math</category>
        
      </item>
    
      <item>
        <title>[Interview Problem] Maximum Keener</title>
        <description>&lt;p&gt;This is an explanation for the “Course Schedule” problem on Leetcode.&lt;/p&gt;

&lt;h2 id=&quot;prerequisites&quot;&gt;Prerequisites&lt;/h2&gt;

&lt;p&gt;Basic understanding of graph algorithms.&lt;/p&gt;

&lt;h2 id=&quot;problem&quot;&gt;Problem&lt;/h2&gt;

&lt;p&gt;There are $n$ courses you want to take. You number them from $[0, n - 1]$. Each course has 0 or more prerequisites and they are given to you in an array of pairs of numbers, where the first number in the pair is the course and the second number in the pair is its prerequisite.&lt;/p&gt;

&lt;p&gt;For example, &lt;code class=&quot;highlighter-rouge&quot;&gt;[[1,0],[1,2]]&lt;/code&gt;. Here, course 1 has two prerequisite courses, courses 0 and 2.&lt;/p&gt;

&lt;p&gt;Given a course schedule, we want to know whether we can take all courses, like a true keener. In the previous example, we are able to take all courses since we can first take course 0, then course 2, then take course 1.&lt;/p&gt;

&lt;p&gt;In this example, &lt;code class=&quot;highlighter-rouge&quot;&gt;[[1,0],[0,1]]&lt;/code&gt;, we cannot since if we wanted to take course 1, we needed to take course 0 and vice versa.&lt;/p&gt;

&lt;h2 id=&quot;ideas-and-solution&quot;&gt;Ideas and solution&lt;/h2&gt;

&lt;p&gt;The key to this problem is to identify that it’s a graph-related problem (specifically a directed graph). The courses are the nodes of the graph and the directed vertices are the prerequisite pairs. Knowing this, the problem can actually be solved very quickly with a basic graph algorithm.&lt;/p&gt;

&lt;p&gt;After understanding that this is a graph problem, we need to try to establish connections between certain graph properties and the problem’s properties. We note that in the problem definition, the example of a course schedule that does not work has a directed cycle in its graph. Specifically, the entire graph that represents that schedule is a directed cycle.&lt;/p&gt;

&lt;div class=&quot;image-center&quot;&gt;&lt;img src=&quot;http://imgur.com/gI9dKto.jpg&quot; width=&quot;400&quot; /&gt;&lt;/div&gt;

&lt;p&gt;Now exploring this directed cycle idea further, we notice that for any course schedule who’s corresponding graph has a schedule, we will not be able to take all courses in the schedule. So all we need now is an algorithm that can quickly detect a directed cycle in a graph.&lt;/p&gt;

&lt;div class=&quot;image-center&quot;&gt;&lt;img src=&quot;http://imgur.com/J3esOZb.jpg&quot; width=&quot;400&quot; /&gt;&lt;/div&gt;

&lt;p&gt;Fortunately, this is a very popular problem and one method to detect directed cycles in a directed graph is to perform a &lt;strong&gt;topological sort&lt;/strong&gt; on its nodes. The definition of a topological sort by Wikipedia is:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;A linear ordering of its vertices such that for every directed edge uv from vertex u to vertex v, u comes before v in the ordering&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;If there was a cycle in a graph, and vertex u and v was part of the cycle, then no topological sort can exist since u will have to simultaneously come before v and after v in the sort, which is not possible. A topological sort can be done with both a &lt;a href=&quot;https://en.wikipedia.org/wiki/Topological_sorting#Depth-first_search&quot;&gt;DFS&lt;/a&gt; and a &lt;a href=&quot;https://www.quora.com/Can-topological-sorting-be-done-using-BFS&quot;&gt;BFS&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The complexity of both algorithms is $O(V + E)$ where $V$ is the number of vertices and $E$ is the number of edges.&lt;/p&gt;

&lt;h2 id=&quot;coded-solution-python&quot;&gt;Coded solution (Python)&lt;/h2&gt;

&lt;h3 id=&quot;bfs&quot;&gt;BFS&lt;/h3&gt;

&lt;p&gt;The indegree of a node is the number of edges pointing at the node. The idea of the BFS solution is to find a node with an indegree of 0, remove it and all its out-going edges from the graph, and rinse and repeat. If there comes a point where there are no nodes with indegree of 0, but there are still nodes left in the graph, the graph has a cycle. Else, the graph has no cycle.&lt;/p&gt;

&lt;p&gt;Note, this relates to a topological sort because we are removing nodes in the graph in topological order.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def bfs_solution(num_courses, prerequisites):
    # graph represented as adjacency lists
    graph = [[] for _ in xrange(num_courses)]
    # construct graph
    for course, prereq in prerequisites:
        graph[prereq].append(course)

    # determine in-degrees for each course
    indegrees = [0 for _ in xrange(num_courses)]
    for neighbours in graph:
        for neighbour in neighbours:
            indegrees[neighbour]++

    for i in xrange(num_courses):
        course_indegree_zero = None
        for course in xrange(num_courses):
            if indegrees[course] == 0:
                course_indegree_zero = course
                break
        if course_indegree_zero == None:
            return False
        indegrees[course_indegree_zero] = -1
        for neighbour in graph[course_indegree_zero]:
            indegrees[course] -= 1
    return True
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;dfs&quot;&gt;DFS&lt;/h3&gt;

&lt;p&gt;The idea of the DFS solution is to basically conduct a DFS and if we encounter a &lt;strong&gt;back edge&lt;/strong&gt;, which is basically reaching a node that is currently seen in the DFS but not completed, then there is a cycle. Every time we open a node for DFS, we mark it as -1 and if we see another node that is marked as -1 in the DFS, then we have encountered a seen but incomplete node and thus a back edge.&lt;/p&gt;

&lt;p&gt;If we complete a node, we mark the node as 1. This relates to a topological sort because we complete nodes in a topological order.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def dfs_cycle_detected(course, graph, visited):
    if visited[course] == -1:
        return True
    elif visited[course] == 1:
        return False
    visited[course] == -1
    for i in graph[course]:
        if dfs_cycle_detected(i, graph, visited):
            return True
    visited[course] == 1
    return False

# if there is a course n has a prerequisite course j, then there is a vertex from j to n in the graph
def dfs_solution(num_courses, prerequisites):
    # graph represented as adjacency lists
    graph = [[] for _ in xrange(num_courses)]
    # visited array, one element for each course
    #   value = 0, not yet visited
    #   value = -1, course is being depth-first-searched but hasn&#39;t completed yet
    #   value = 1, course was depth-first-searched and it completed without detecting a cycle
    visited = [0 for _ in xrange(num_courses)]
    # construct graph
    for course, prereq in prerequisites:
        graph[prereq].append(course)
    for course in xrange(num_courses):
        if dfs_cycle_detected(course, graph, visited):
            return False
    return True
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Sun, 03 Apr 2016 18:19:06 -0400</pubDate>
        <link>http://interviewperfect.github.io//interview-problem-maximum-keener/</link>
        <guid isPermaLink="true">http://interviewperfect.github.io//interview-problem-maximum-keener/</guid>
        
        
        <category>easy</category>
        
        <category>graphs</category>
        
      </item>
    
      <item>
        <title>[Interview Problem] Sort a K-sorted Array</title>
        <description>&lt;h2 id=&quot;problem&quot;&gt;Problem&lt;/h2&gt;

&lt;p&gt;We have a very unique array where every number is at most $k - 1$ units away from its correct sorted spot (sorted from least to greatest). Let’s call such an array a k-sorted array. How can we correctly sort a k-sorted array in the most efficient way possible?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Runtime:&lt;/strong&gt; ideally we can get an &lt;span class=&quot;spoiler&quot;&gt;$O(n \log k)$&lt;/span&gt; solution.&lt;/p&gt;

&lt;h2 id=&quot;ideas-and-solution&quot;&gt;Ideas and solution&lt;/h2&gt;

&lt;p&gt;As before, we always start a problem by trying to consider all possible options.&lt;/p&gt;

&lt;p&gt;Our core problem is we want to sort an array. We can easily solve this problem by just using a naive $O(n \log n)$ sorting algorithm and be done with it &lt;strong&gt;(idea 1)&lt;/strong&gt;. However, this will probably not give us many points with the interviewer.&lt;/p&gt;

&lt;p&gt;What else can we do? Well we know that every number in the array is at most $k - 1$ units away from its correctly sorted spot. Let’s try to take advantage of this property as much as possible.&lt;/p&gt;

&lt;p&gt;Our next approach can be to make the problem simpler by adding constraints to the original problem &lt;strong&gt;(idea 2)&lt;/strong&gt;. Let’s take one number in this array, how can we place it in its correct spot? We know that for a number at index $x$, its correct spot must be one index within the range $[x - (k - 1), x + (k - 1)]$. So does sorting all the numbers within this range put number $x$ in its correct spot? This is actually not necessarily true.&lt;/p&gt;

&lt;p&gt;Let’s take the sorted array as an example: &lt;code class=&quot;highlighter-rouge&quot;&gt;[1, 2, 5, 6, 7, 8, 49, 50, 99, 100]&lt;/code&gt;. Its k-sorted version could be &lt;code class=&quot;highlighter-rouge&quot;&gt;[1, 6, 2, 8, 5, 7, 49, 50, 99, 100]&lt;/code&gt; (k = 3). Let’s take 5 and sort the numbers &lt;code class=&quot;highlighter-rouge&quot;&gt;[2, 8, 5, 7, 49] = [2, 5, 7, 8, 49]&lt;/code&gt;. If we put the partial, sorted array back into the original array, &lt;code class=&quot;highlighter-rouge&quot;&gt;[1, 6, 2, 5, 7, 8, 49, 50, 99, 100]&lt;/code&gt;, 5 is not in its correct spot.&lt;/p&gt;

&lt;p&gt;Our initial attempt to take advantage of the k-sorted property failed. Let’s not give up! In idea 2, we tried to find the correct position for a random number in the array. Let’s make this simplified problem even simpler by trying to find the correct position for the first number in the k-sorted array &lt;strong&gt;(idea 3)&lt;/strong&gt;. We notice that the range of possible correct indices for this number is $[0, k - 1]$. Interesting, this is much less than for a random index $x$, which was $[x - (k - 1), x + (k - 1)]$. For the second number in the k-sorted array, the range of possible correct indices is $[0, k]$ and so on…&lt;/p&gt;

&lt;p&gt;At this point we can see that if we actually sorted the first $k$ numbers, or indices within the range $[0, k - 1]$, of the k-sorted array, the least number in this sort must be the first number in the correctly sorted array. The first number of the correct sorted array cannot be at an index greater than $k - 1$ in the k-sorted array or else it would not be a k-sorted array. So let’s sort the first $k$ numbers, remove the least number, and put it in an empty array. A good start in constructing the correctly sorted array. Our k-sorted array is now one number less but it’s still a k-sorted array! We can abuse this property again by sorting the first k numbers of our smaller k-sorted array, take the least number from the sort, and add it to our partially constructed, correctly sorted array. If we keeping doing this, we can reconstruct our correctly sorted array. Nice! A solution.&lt;/p&gt;

&lt;p&gt;Let’s take a step back. Did we actually make progress though? Our new solution is $O(n k \log k)$ which might or might not be better than a naive sort, which is $O(n \log n)$. It all depends on the value of $k$ (we could actually do $O(n k)$ but I won’t describe it in this post). Well there’s a sweet data structure out there that can use our new solution but achieve an optimal runtime of $O(n \log k)$.&lt;/p&gt;

&lt;p&gt;The data structure is called a &lt;strong&gt;minimum priority queue&lt;/strong&gt;. Construction of this queue takes linear time, which, in our case is $O(k)$. The queue allows us to pop the minimum number in $O(\log k)$ time. Insertion is also $O(\log k)$ time. The idea is to construct a minimum priority queue of the first k numbers of the k-sorted array, pop the minimum and put it in our partially constructed correctly sorted array. Next, we insert the next number in our k-sorted array to our queue and pop the minimum again. This is the second number in our correctly sorted array. We keep doing this for all numbers in the k-sorted array and we will have the correctly sorted array.&lt;/p&gt;

&lt;p&gt;The runtime for this solution is $O(k)$ for queue construction, $O(n \log k)$ for the insertions and $O(n \log k)$ for the minimum pops. Overall, the runtime is $O(n \log k)$.&lt;/p&gt;

&lt;h2 id=&quot;coded-solution-python&quot;&gt;Coded solution (Python)&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def sort(array, k):
    min_heap = []
    for i in xrange(len(array)):
        if len(min_heap) &amp;lt; k:
            heapq.heappush(min_heap, array[i])
        else:
            array[i - k] = heapq.heappop(min_heap)
            heapq.heappush(min_heap, array[i])
    for i in xrange(len(array) - k, len(array)):
        array[i] = heapq.heappop(min_heap)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Sun, 03 Apr 2016 00:57:05 -0400</pubDate>
        <link>http://interviewperfect.github.io//sort-a-k-sorted-array/</link>
        <guid isPermaLink="true">http://interviewperfect.github.io//sort-a-k-sorted-array/</guid>
        
        
        <category>medium</category>
        
        <category>arrays</category>
        
      </item>
    
      <item>
        <title>[Interview Problem] Godzilla vs 2D City</title>
        <description>&lt;h2 id=&quot;problem&quot;&gt;Problem&lt;/h2&gt;

&lt;p&gt;There’s a 2D city represented by an array. Each element in the array represents a building. The number in the array represents the building’s height. Whenever a building topples, it topples the next &lt;code class=&quot;highlighter-rouge&quot;&gt;height - 1&lt;/code&gt; buildings after it. Godzilla can only push over one building and can only push from the left side. Which building should Godzilla push so that the most buildings will be destroyed?&lt;/p&gt;

&lt;p&gt;To clarify, buildings that a building topple will also cause buildings after it to topple, creating a chain reaction. For example, for a city represented by the array &lt;code class=&quot;highlighter-rouge&quot;&gt;[1, 1, 2, 3, 5, 1, 2, 1]&lt;/code&gt;, the optimal building to topple is the building at index 2 since it topples the building at index 3 (of height 3) which topples buildings at index 4 and 5. Toppling the building at index 4 causes all buildings afterwards to topple since it’s height is 5. Therefore, toppling the building at index 2 topples 6 buildings by chain reaction and it’s the most out of any other building.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Runtime:&lt;/strong&gt; we want an &lt;span class=&quot;spoiler&quot;&gt;$O(n)$&lt;/span&gt; solution.&lt;/p&gt;

&lt;h2 id=&quot;ideas-and-solution&quot;&gt;Ideas and solution&lt;/h2&gt;

&lt;p&gt;As always, after understanding the solution, we need to try to consider all possible options and not be afraid of exploring an option even though it will obviously lead to an inefficient solution. An inefficient solution is better than no solution.&lt;/p&gt;

&lt;p&gt;The obvious, brute force solution to this problem is to iterate through the array and for each building, we determine how many buildings we topple in total if we topple that building &lt;strong&gt;(idea 1)&lt;/strong&gt;. We can do this using the following Python code. We note that only purely doing this takes $O(n^2)$.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def topple(city, building_index):
    max_index = building_index + city[building_index] - 1
    while True:
        last_max_index = max_index
        for i in xrange(last_max_index, building_index):
            if i + city[i] - 1 &amp;gt; max_index:
                max_index = i + city[i] - 1
        if last_max_index == max_index:
            break
    return max_index - building_index + 1

def inefficient_solution(city):
    max_buildings_toppled = 0
    building_index = 0
    for i in xrange(len(city)):
        if topple(city, i) &amp;gt; max_buildings_toppled:
            building_index = i
    return building_index
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Often a great technique to solving problems is to consider if we are repeating any calculations, thus allowing us to eliminate these steps and make the solution more efficient. Let’s see if we can apply this technique to this problem &lt;strong&gt;(idea 2)&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;We note that in our previous solution, when we called &lt;code class=&quot;highlighter-rouge&quot;&gt;topple&lt;/code&gt; on one building, we are also basically calling &lt;code class=&quot;highlighter-rouge&quot;&gt;topple&lt;/code&gt; on each building this building topples and so on until the chain reaction ends. So if this building topples 3 buildings, why do we need to call &lt;code class=&quot;highlighter-rouge&quot;&gt;topple&lt;/code&gt; on the next 3 buildings if we already tried toppling them? We are repeating these calculations.&lt;/p&gt;

&lt;p&gt;Let’s consider this using a different viewpoint. If one building, Building 3, topples all buildings until Building 8, if there exists a building between Building 3 and Building 8, say Building 5, that will topple all buildings till Building 11, then mustn’t Building 3 topple all buildings till Building 11 since Building 3 also topples Building 5?&lt;/p&gt;

&lt;p&gt;By eliminating these extra calculations, we realize that we have reached our target $O(n)$ solution since we only ever need to “visit” a building once.&lt;/p&gt;

&lt;h2 id=&quot;coded-solution-python&quot;&gt;Coded solution (Python)&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def topple(city, building_index):
    max_index = building_index + city[building_index] - 1
    while True:
        last_max_index = max_index
        for i in xrange(last_max_index, building_index):
            if i + city[i] - 1 &amp;gt; max_index:
                max_index = i + city[i] - 1
        if last_max_index == max_index:
            break
    return max_index - building_index + 1

def inefficient_solution(city):
    max_buildings_toppled = 0
    building_index = 0
    current_building_index = building_index
    while current_building_index &amp;lt; len(city):
        number_of_buildings_toppled = topple(city, current_building_index)
        if number_of_buildings_toppled == 0:
            current_building_index += 1
        else:
            if number_of_buildings_toppled &amp;gt; max_buildings_toppled:
                building_index = i
            current_building_index += number_of_buildings_toppled
    return building_index
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Sat, 02 Apr 2016 23:51:21 -0400</pubDate>
        <link>http://interviewperfect.github.io//interview-problem-godzilla-vs-2d-city/</link>
        <guid isPermaLink="true">http://interviewperfect.github.io//interview-problem-godzilla-vs-2d-city/</guid>
        
        
        <category>medium</category>
        
        <category>arrays</category>
        
      </item>
    
      <item>
        <title>[Interview Problem] Buying Stocks</title>
        <description>&lt;h2 id=&quot;problem&quot;&gt;Problem&lt;/h2&gt;

&lt;p&gt;We are interested in buying Amazon stock. Amazon stock prices change once at the start of every day. We are given Amazon stock data for a month, we need to determine two days such that the difference between stock prices for the two days is the greatest and the later day has a larger stock price.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Runtime:&lt;/strong&gt; ideally we can get an &lt;span class=&quot;spoiler&quot;&gt;$O(n)$&lt;/span&gt; solution.&lt;/p&gt;

&lt;h2 id=&quot;ideas-and-solution&quot;&gt;Ideas and solution&lt;/h2&gt;

&lt;p&gt;Remember that the first thing to solving a problem after we understand it is to try to consider all possible options.&lt;/p&gt;

&lt;p&gt;For a problem on arrays, we can first think about sorting &lt;strong&gt;(idea 1)&lt;/strong&gt;. Even though sorting really implies that we are stuck with an $O(n \log n)$ solution, in an interview a solved, inefficient solution is always better than no solution. Inefficient solutions are often easier to come up with and may help lead to more efficient solutions.&lt;/p&gt;

&lt;p&gt;We notice that the solution has a dependency on time, since the day with the greater price must be after the day with the lesser price. So sorting causes us to lose information in the new sorted array, which is not what we want. Relying on a sorted array alone will not be useful to us. Perhaps it’s better to invest our time in something besides sorting.&lt;/p&gt;

&lt;p&gt;The next idea is to add constraints to the problem to make it simpler &lt;strong&gt;(idea 2)&lt;/strong&gt;. Let’s try this: if we must sell a stock at a set specific day, what prior day should we buy the stock on to get the most profit?&lt;/p&gt;

&lt;p&gt;The answer, of course, is the day with the lowest stock price out of all the days before the day we sell. So this makes iterating through the array and keeping a minimum stock price seen very promising. Best of all, our algorithm can still be $O(1)$ doing so.&lt;/p&gt;

&lt;p&gt;So now as we progress in days, we have the minimum stock price we have seen before, and this also means that at each and every new day we encounter, we know the maximal profit we can get if we must sell on this new day. Guess what? We have the $O(1)$ solution now. We just need to iterate through the array, keeping a minimum stock price seen and when as well as maximum profit seen and when (which we can get from minimum stock price seen) and by the end of iterating through the array we will know the maximum profit plus the days with which we achieve this maximum profit.&lt;/p&gt;

&lt;p&gt;We note that this solution is an example of a &lt;strong&gt;greedy algorithm&lt;/strong&gt;.&lt;/p&gt;

&lt;h2 id=&quot;coded-solution-python&quot;&gt;Coded solution (Python)&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def solution(self, stock_prices):
    first_day = 0
    second_day = None
    min_price = stock_prices[0]
    max_profit = 0

    for i in xrange(1, len(stock_prices)):
        if stock_prices[i] &amp;lt; min_price:
            min_price = stock_prices[i]
            first_day = i
        elif stock_prices[i] - min_price &amp;gt; max_profit:
            max_profit = stock_prices[i] - min_price
            second_day = i

    return max_profit
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Sat, 02 Apr 2016 03:58:26 -0400</pubDate>
        <link>http://interviewperfect.github.io//buying-stocks/</link>
        <guid isPermaLink="true">http://interviewperfect.github.io//buying-stocks/</guid>
        
        
        <category>medium</category>
        
        <category>arrays</category>
        
      </item>
    
  </channel>
</rss>
